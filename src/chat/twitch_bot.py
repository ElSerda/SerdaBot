"""Module de gestion du bot Twitch SerdaBot.

Ce module impl√©mente les fonctionnalit√©s principales du bot Twitch, notamment :
- La gestion des commandes (!ask, !game, etc.)
- La traduction automatique des messages
- La d√©tection et le timeout des bots spam
- La gestion des cooldowns

Le bot utilise TwitchIO comme base et ajoute des fonctionnalit√©s personnalis√©es.
"""

import asyncio
import re
import sys
import traceback
from datetime import datetime, timedelta

from twitchio.ext import commands  # type: ignore

from src.config.config import load_config
from src.core.commands.ask_command import handle_ask_command
from src.core.commands.cache_commands import (
    handle_cacheadd_command,
    handle_cacheclear_command,
    handle_cachestats_command,
)
from src.core.commands.chill_command import handle_chill_command
from src.core.commands.donation_command import handle_donation_command
from src.core.commands.game_command import handle_game_command
from src.utils.cache_manager import load_cache
from src.utils.conversation_manager import ConversationManager
from src.utils.llm_detector import check_llm_status, get_llm_mode
from src.utils.translator import Translator
from src.utils.twitch_api_sender import TwitchAPISender
from src.utils.twitch_automod import TwitchAutoMod

CONFIG = load_config()


# Gestionnaire global pour capturer les exceptions non g√©r√©es
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    print("[ERROR] Une exception non g√©r√©e a √©t√© captur√©e :")
    print("".join(traceback.format_exception(exc_type, exc_value, exc_traceback)))


sys.excepthook = handle_exception


class TwitchBot(commands.Bot):  # pyright: ignore[reportPrivateImportUsage]
    """Bot Twitch personnalis√© avec gestion des commandes et de la traduction automatique.

    Cette classe √©tend le Bot TwitchIO standard avec des fonctionnalit√©s personnalis√©es
    comme la traduction automatique, la gestion du spam et diverses commandes utilitaires.
    """

    def __init__(self, config_or_path: dict | str = 'src/config/config.yaml'):
        # Support √† la fois dict (d√©j√† charg√©) et string (path √† charger)
        config: dict
        if isinstance(config_or_path, dict):
            config = config_or_path
        else:
            config = load_config(config_or_path)
        
        self.config: dict = config
        
        # Initialize TwitchIO Bot parent class
        super().__init__(
            token=self.config["twitch"]["token"],
            prefix='!',
            initial_channels=[self.config["bot"]["channel"]]
        )
        
        # Initialise le cache (avec reset si mode exp√©rimental)
        reset_cache = self.config.get("bot", {}).get("reset_cache_on_boot", False)
        load_cache(reset=reset_cache)
        self.cooldowns = {}
        self.botname = self.config["bot"]["name"].lower()
        self.enabled = self.config["bot"].get("enabled_commands", [])

        # Initialize translator
        self.translator = Translator()
        self.auto_translate = self.config["bot"].get("auto_translate", True)

        # Initialize conversation manager (contexte conversationnel)
        rate_limiting = self.config.get("rate_limiting", {})
        max_idle_time = rate_limiting.get("max_idle_time", 3600)
        max_messages = rate_limiting.get("max_messages_per_user", 12)
        self.conversation_manager = ConversationManager(ttl_seconds=max_idle_time, max_messages=max_messages)
        print(f"üí¨ ConversationManager activ√© (TTL: {max_idle_time}s, max: {max_messages} messages)")

        # Initialize AutoMod (if credentials available)
        try:
            self.automod = TwitchAutoMod(
                client_id=self.config["twitch"]["client_id"],
                access_token=self.config["twitch"]["token"].replace("oauth:", ""),
                broadcaster_id=self.config["twitch"].get("broadcaster_id", self.config["twitch"]["bot_id"]),
                moderator_id=self.config["twitch"]["bot_id"]
            )
            self.automod_enabled = True
        except (KeyError, TypeError) as e:
            print(f"‚ö†Ô∏è AutoMod d√©sactiv√© (config manquante): {e}")
            self.automod_enabled = False

        # Initialize API Sender (badge bot ü§ñ)
        try:
            self.api_sender = TwitchAPISender(
                client_id=self.config["twitch"]["client_id"],
                app_access_token=self.config["twitch"]["app_access_token"],
                bot_user_token=self.config["twitch"]["app_access_token"],  # On utilise l'app token
                broadcaster_id=self.config["twitch"]["broadcaster_id"],
                sender_id=self.config["twitch"]["bot_id"]
            )
            self.api_enabled = True
            print("ü§ñ API Send Chat Message activ√©e (badge bot enabled)")
        except (KeyError, TypeError) as e:
            print(f"‚ö†Ô∏è API Send Chat d√©sactiv√©e (config manquante): {e}")
            self.api_enabled = False

        # Track first connection for welcome message
        self._first_connect_done = False
        
        # Reconnection tracking (TwitchIO 2.x native - Solution optimis√©e)
        self._booted = False
        
        # D√©tection du LLM au d√©marrage
        llm_mode = get_llm_mode(self.config)
        
        if llm_mode == "disabled":
            self.llm_available = False
            print("üîá LLM d√©sactiv√© manuellement (config ou LLM_MODE=disabled)")
        elif llm_mode == "enabled":
            self.llm_available = True
            print("üîä LLM forc√© activ√© (config ou LLM_MODE=enabled)")
        else:  # auto
            self.llm_available, status_msg = check_llm_status(self.config)
            print(status_msg)
            if not self.llm_available:
                print("üîÑ Note: Le LLM sera rev√©rifi√© √† chaque appel (retry intelligent)")
        self._channel_joined_once = False  # Track premi√®re connexion vs reconnexion
        self._last_reconnect_announce = 0  # Timestamp pour cooldown anti-spam

    async def event_ready(self):
        print(f'\nü§ñ Connected to Twitch chat as {self.nick}')
        self._display_model_config()
        print("‚òïÔ∏è Boot complete.")
        print("ü§ñ SerdaBot is online and ready.")
        self._booted = True

        # Envoie le message de connexion uniquement √† la premi√®re connexion
        if not self._first_connect_done:
            self._first_connect_done = True
            connect_message = self.config["bot"].get("connect_message", "").strip()
            if connect_message and self.connected_channels:
                try:
                    await self.safe_send(self.connected_channels[0], connect_message)
                except Exception as e:
                    print(f"[ERROR] Impossible d'envoyer le message de connexion : {e}")

    def _display_model_config(self):
        """Affiche la configuration du mod√®le au d√©marrage."""
        try:
            print("\nüß† === CONFIGURATION MOD√àLE ===")

            # Endpoint externe (LM Studio/FastAPI)
            endpoint = self.config["bot"].get("model_endpoint") or self.config["bot"].get("api_url")
            if endpoint:
                endpoint_type = (
                    "LM Studio"
                    if "1234" in endpoint
                    else "FastAPI" if "8000" in endpoint else "Externe"
                )
                print(f"üåê {endpoint_type}: {endpoint}")

            # OpenAI fallback
            if self.config["bot"].get("model_type") == "openai":
                model = self.config["bot"].get("openai_model", "gpt-3.5-turbo")
                print(f"üåê Fallback: OpenAI ({model})")

            # Commandes activ√©es
            enabled = self.config["bot"].get("enabled_commands", [])
            print(f"‚ö° Commandes: {', '.join(enabled)}")
            print("=" * 35)
        except Exception as e:
            print(f"[ERROR] Une erreur s'est produite lors de l'affichage de la configuration : {e}")

    def _is_bot_mentioned(self, message, content: str, cleaned: str) -> bool:
        """V√©rifie si le bot est mentionn√© dans le message.
        
        D√©tecte 3 types de mentions:
        1. Nom du bot dans le message (ex: "serdabot tu es l√†?")
        2. Mention @ (ex: "@serdabot bonjour")
        3. R√©ponse Twitch (bouton "R√©pondre" dans le chat)
        
        Args:
            message: L'objet message TwitchIO
            content: Le contenu brut du message
            cleaned: Le contenu nettoy√© (sans caract√®res sp√©ciaux)
            
        Returns:
            bool: True si le bot est mentionn√©
        """
        # 1. V√©rifier si le nom du bot est dans le message nettoy√© (m√©thode originale)
        words = re.findall(r"\b\w+\b", cleaned)
        if self.botname in words:
            return True
        
        # 2. V√©rifier les mentions @ dans le contenu original
        # Pattern: @botname (au d√©but ou milieu de phrase)
        mention_pattern = rf"@{re.escape(self.botname)}\b"
        if re.search(mention_pattern, content.lower()):
            return True
        
        # 3. V√©rifier si c'est une r√©ponse Twitch au bot
        # TwitchIO expose les tags IRC via message.tags
        if hasattr(message, 'tags') and message.tags:
            # Le tag 'reply-parent-user-login' contient le nom de l'utilisateur auquel on r√©pond
            reply_parent = message.tags.get('reply-parent-user-login', '').lower()
            if reply_parent == self.botname:
                return True
        
        return False

    async def run_with_cooldown(self, user, action):
        """Execute action with cooldown management and error handling."""
        try:
            await action()
        except ValueError as e:
            print(f"‚ùå Erreur de valeur dans la commande de @{user} : {e}")
        except ConnectionError as e:
            print(f"‚ùå Erreur de connexion pour @{user} : {e}")
        except TimeoutError as e:
            print(f"‚ùå D√©lai d'attente d√©pass√© pour @{user} : {e}")
        except asyncio.CancelledError:
            print(f"‚ùå Commande annul√©e pour @{user}")
            raise  # On re-l√®ve cette exception car elle est importante pour asyncio
        except (RuntimeError, AttributeError, KeyError) as e:
            print(f"‚ùå Erreur inattendue pour @{user} : {type(e).__name__} - {e}")
            # Log l'erreur pour debug ult√©rieur
            print("D√©tails de l'erreur:")
            print(traceback.format_exc())
        finally:
            self.cooldowns[user] = datetime.now()
            print(
                f'[{datetime.now().strftime("%H:%M:%S")}] ‚úÖ Pr√™t √† √©couter de nouvelles commandes.'
            )

    async def event_message(self, message) -> None:
        """G√®re les messages re√ßus dans le chat.

        Cette m√©thode est appel√©e √† chaque message re√ßu. Elle g√®re :
        - La d√©tection de spam
        - La traduction automatique
        - Les commandes du bot

        Args:
            payload: Le message re√ßu du chat Twitch
        """
        if message.echo:
            return

        content = str(message.content).strip()
        user = str(message.author.name or "user").lower()
        now = datetime.now()
        cooldown = self.config["bot"].get("cooldown", 60)
        
        # Remove @mention from start for command parsing
        content_without_mention = re.sub(r"^@\w+\s+", "", content)
        cleaned = re.sub(r"[^\w\s!?]", "", content_without_mention.lower())
        
        # Check if bot is mentioned (nom, @mention, ou reply Twitch)
        is_mentioned = self._is_bot_mentioned(message, content, cleaned)

        # === CHECK BOT WHITELIST/BLACKLIST ===
        if self.translator.should_ignore_bot(user):
            print(f"üö´ Bot ignor√© (whitelist/blacklist): {user}")
            return

        # === CHECK SI C'EST UNE COMMANDE MOD (avant spam detection) ===
        is_mod = (
            getattr(message.author, 'is_mod', False)
            or user == message.channel.name.lower()
        )

        # Si c'est un mod qui utilise une commande de gestion, on skip la d√©tection de spam
        is_management_command = is_mod and any(
            cleaned.startswith(cmd) for cmd in [
                "!adddev", "!removedev", "!deldev", "!listdevs",
                "!blocksite", "!unblocksite", "!blockedlist",
                "!addwhitebot", "!delwhitebot", "!addblackbot", "!delblackbot",
                "!whitebots", "!blackbots", "!translate ", "!trad "
            ]
        )

        # === SPAM BOT DETECTION & BAN (sauf si commande de gestion) ===
        if not is_management_command:
            channel_owner = message.channel.name.lower()
            if self.translator.is_spam_bot(user, content, channel_owner):
                print(f"üö´ Spam bot d√©tect√©: {user} - Message: {content[:50]}")
                try:
                    # Timeout le bot spam (60s = 1min) - Via commande chat
                    timeout_command = f"/timeout {user} 60"
                    await message.channel.send(timeout_command)
                    print(f"‚úÖ Commande timeout envoy√©e: {user} (60 sec)")
                except (ConnectionError, TimeoutError) as e:
                    print(f"‚ùå Erreur r√©seau lors du timeout de {user}: {e}")
                except ValueError as e:
                    print(f"‚ùå Erreur de valeur lors du timeout de {user}: {e}")
                except RuntimeError as e:
                    print(f"‚ùå Erreur d'ex√©cution lors du timeout de {user}: {e}")
                return
            else:
                # Log pour debug (optionnel)
                print(f"üí¨ Message de {user}: {content[:30]}... [OK]")

        # === AUTO-TRADUCTION DEVS ===
        if self.auto_translate and self.translator.should_translate(user, content):
            try:
                translated = self.translator.translate(content, "en", "fr")
                if translated and not translated.startswith("‚ö†Ô∏è"):
                    formatted = f"üåê @{user}: {content}\n‚îî‚îÄ üá´üá∑ {translated}"
                    await self.safe_send(message.channel, formatted)
                elif translated and translated.startswith("‚ö†Ô∏è"):
                    # Erreur de traduction, mais on affiche quand m√™me un message d'info
                    await self.safe_send(message.channel, f"üåê @{user}: {content}\n‚îî‚îÄ {translated}")
            except (RuntimeError, ValueError, KeyError) as e:
                print(f"‚ùå Erreur auto-traduction pour {user}: {e}")
                # En cas d'erreur critique, on affiche juste le message original
                await self.safe_send(
                    message.channel,
                    f"üåê @{user}: {content}\n‚îî‚îÄ ‚ö†Ô∏è Traduction indisponible"
                )

        # Check cooldown
        if user in self.cooldowns and now - self.cooldowns[user] < timedelta(seconds=cooldown):
            remaining = int(cooldown - (now - self.cooldowns[user]).total_seconds())
            print(f"‚è≥ {user} en cooldown ({remaining}s restant)")
            return

        # === COMMANDES TRADUCTION (MOD ONLY) ===
        if cleaned.startswith("!adddev") and is_mod:
            parts = content.split()
            if len(parts) > 1:
                username = parts[1].strip("@")
                self.translator.add_dev(username)
                await self.safe_send(
                    message.channel, f"‚úÖ @{username} ajout√© √† la whitelist traduction !"
                )
            else:
                await self.safe_send(message.channel,  f"@{user} Usage: !adddev @username")
            return

        elif (cleaned.startswith("!removedev") or cleaned.startswith("!deldev")) and is_mod:
            parts = content.split()
            if len(parts) > 1:
                username = parts[1].strip("@")
                if self.translator.remove_dev(username):
                    await self.safe_send(message.channel,  f"‚úÖ @{username} retir√© de la whitelist.")
                else:
                    await self.safe_send(
                        message.channel, f"‚ÑπÔ∏è @{username} n'est pas dans la whitelist."
                    )
            else:
                cmd_used = "!deldev" if cleaned.startswith("!deldev") else "!removedev"
                await self.safe_send(message.channel,  f"@{user} Usage: {cmd_used} @username")
            return

        elif cleaned.startswith("!listdevs") and is_mod:
            devs = self.translator.get_devs()
            if devs:
                devs_str = ", ".join(f"@{d}" for d in devs)
                await self.safe_send(
                    message.channel, f"üìã Devs whitelist√©s ({len(devs)}): {devs_str}"
                )
            else:
                await self.safe_send(message.channel,  "‚ÑπÔ∏è Aucun dev dans la whitelist.")
            return

        elif cleaned.startswith("!blocksite") and is_mod:
            parts = content.split()
            if len(parts) > 1:
                site = parts[1].lower()
                self.translator.add_blocked_site(site)
                await self.safe_send(
                    message.channel,
                    f"üö´ Site '{site}' bloqu√© ! "
                    f"Les bots contenant ce mot seront ban automatiquement.",
                )
            else:
                await self.safe_send(message.channel,  f"@{user} Usage: !blocksite <nom_site>")
            return

        elif cleaned.startswith("!unblocksite") and is_mod:
            parts = content.split()
            if len(parts) > 1:
                site = parts[1].lower()
                if self.translator.remove_blocked_site(site):
                    await self.safe_send(message.channel,  f"‚úÖ Site '{site}' d√©bloqu√©.")
                else:
                    await self.safe_send(message.channel,  f"‚ÑπÔ∏è '{site}' n'est pas bloqu√©.")
            else:
                await self.safe_send(message.channel,  f"@{user} Usage: !unblocksite <nom_site>")
            return

        elif cleaned.startswith("!blockedlist") and is_mod:
            sites = self.translator.get_blocked_sites()
            if sites:
                sites_str = ", ".join(sites)
                await self.safe_send(
                    message.channel, f"üö´ Sites bloqu√©s ({len(sites)}): {sites_str}"
                )
            else:
                await self.safe_send(message.channel,  "‚ÑπÔ∏è Aucun site bloqu√©.")
            return

        # === AUTOMOD TWITCH COMMANDS (API) ===
        elif cleaned.startswith("!addbanword") and is_mod:
            if not self.automod_enabled:
                await self.safe_send(message.channel, "‚ö†Ô∏è AutoMod API d√©sactiv√© (config/scopes manquants)")
                return
            
            parts = content.split()
            if len(parts) > 1:
                word = " ".join(parts[1:])  # Support phrases avec espaces
                print(f"[AUTOMOD] üìû Appel API add_blocked_term pour '{word}'...")
                result = await self.automod.add_blocked_term(word)
                if result:
                    print(f"[AUTOMOD] ‚úÖ Confirmation : mot '{word}' ajout√© avec succ√®s")
                    await self.safe_send(
                        message.channel,
                        f"üö´ Mot '{word}' ajout√© √† l'AutoMod Twitch ! "
                        f"Les messages avec ce mot seront bloqu√©s automatiquement."
                    )
                else:
                    print(f"[AUTOMOD] ‚ùå √âchec : mot '{word}' n'a pas pu √™tre ajout√©")
                    await self.safe_send(message.channel, "‚ùå Erreur lors de l'ajout (v√©rifier scopes OAuth).")
            else:
                await self.safe_send(message.channel, f"@{user} Usage: !addbanword <mot>")
            return

        elif cleaned.startswith("!removebanword") and is_mod:
            if not self.automod_enabled:
                await self.safe_send(message.channel, "‚ö†Ô∏è AutoMod API d√©sactiv√© (config/scopes manquants)")
                return
            
            parts = content.split()
            if len(parts) > 1:
                word = " ".join(parts[1:])
                # Trouver l'ID du term par son texte
                term = await self.automod.find_blocked_term_by_text(word)
                if term:
                    success = await self.automod.remove_blocked_term(term["id"])
                    if success:
                        await self.safe_send(message.channel, f"‚úÖ Mot '{word}' retir√© de l'AutoMod.")
                    else:
                        await self.safe_send(message.channel, "‚ùå Erreur lors de la suppression.")
                else:
                    await self.safe_send(message.channel, f"‚ÑπÔ∏è '{word}' n'est pas dans la liste AutoMod.")
            else:
                await self.safe_send(message.channel, f"@{user} Usage: !removebanword <mot>")
            return

        elif cleaned.startswith("!banwords") and is_mod:
            if not self.automod_enabled:
                await self.safe_send(message.channel, "‚ö†Ô∏è AutoMod API d√©sactiv√© (config/scopes manquants)")
                return
            
            terms = await self.automod.get_blocked_terms()
            if terms:
                words = [t["text"] for t in terms]
                words_str = ", ".join(words)
                await self.safe_send(
                    message.channel,
                    f"üö´ Mots bannis AutoMod ({len(words)}): {words_str}"
                )
            else:
                await self.safe_send(message.channel, "‚ÑπÔ∏è Aucun mot banni dans l'AutoMod.")
            return

        elif cleaned.startswith("!automod") and is_mod:
            if not self.automod_enabled:
                await self.safe_send(message.channel, "‚ö†Ô∏è AutoMod API d√©sactiv√© (config/scopes manquants)")
                return
            
            parts = content.split()
            if len(parts) > 1 and parts[1].isdigit():
                level = int(parts[1])
                if 0 <= level <= 4:
                    success = await self.automod.set_automod_level(level)
                    if success:
                        levels_desc = ["D√©sactiv√©", "Faible", "Mod√©r√©", "√âlev√©", "Strict"]
                        await self.safe_send(
                            message.channel,
                            f"‚úÖ AutoMod configur√©: Niveau {level} ({levels_desc[level]})"
                        )
                    else:
                        await self.safe_send(message.channel, "‚ùå Erreur de configuration.")
                else:
                    await self.safe_send(message.channel, "‚ö†Ô∏è Niveau doit √™tre 0-4")
            else:
                await self.safe_send(message.channel, f"@{user} Usage: !automod <0-4>")
            return

        # === BOT WHITELIST/BLACKLIST COMMANDS ===
        elif cleaned.startswith("!addwhitebot") and is_mod:
            parts = content.split()
            if len(parts) > 1:
                bot_name = parts[1].strip("@")
                self.translator.add_bot_to_whitelist(bot_name)
                await self.safe_send(
                    message.channel,
                    f"‚úÖ Bot @{bot_name} ajout√© √† la whitelist ! "
                    f"SerdaBot ne lui r√©pondra plus."
                )
            else:
                await self.safe_send(message.channel,  f"@{user} Usage: !addwhitebot @bot_name")
            return

        elif cleaned.startswith("!delwhitebot") and is_mod:
            parts = content.split()
            if len(parts) > 1:
                bot_name = parts[1].strip("@")
                if self.translator.remove_bot_from_whitelist(bot_name):
                    await self.safe_send(
                        message.channel, f"‚úÖ Bot @{bot_name} retir√© de la whitelist."
                    )
                else:
                    await self.safe_send(
                        message.channel, f"‚ÑπÔ∏è @{bot_name} n'est pas dans la whitelist."
                    )
            else:
                await self.safe_send(message.channel,  f"@{user} Usage: !delwhitebot @bot_name")
            return

        elif cleaned.startswith("!addblackbot") and is_mod:
            parts = content.split()
            if len(parts) > 1:
                bot_name = parts[1].strip("@")
                self.translator.add_bot_to_blacklist(bot_name)
                await self.safe_send(
                    message.channel,
                    f"üö´ Bot @{bot_name} ajout√© √† la blacklist ! "
                    f"SerdaBot ignorera tous ses messages."
                )
            else:
                await self.safe_send(message.channel,  f"@{user} Usage: !addblackbot @bot_name")
            return

        elif cleaned.startswith("!delblackbot") and is_mod:
            parts = content.split()
            if len(parts) > 1:
                bot_name = parts[1].strip("@")
                if self.translator.remove_bot_from_blacklist(bot_name):
                    await self.safe_send(
                        message.channel, f"‚úÖ Bot @{bot_name} retir√© de la blacklist."
                    )
                else:
                    await self.safe_send(
                        message.channel, f"‚ÑπÔ∏è @{bot_name} n'est pas dans la blacklist."
                    )
            else:
                await self.safe_send(message.channel,  f"@{user} Usage: !delblackbot @bot_name")
            return

        elif cleaned.startswith("!whitebots") and is_mod:
            bots = self.translator.get_whitelisted_bots()
            if bots:
                bots_str = ", ".join(f"@{b}" for b in bots)
                await self.safe_send(
                    message.channel, f"üìã Bots whitelist√©s ({len(bots)}): {bots_str}"
                )
            else:
                await self.safe_send(message.channel,  "‚ÑπÔ∏è Aucun bot dans la whitelist.")
            return

        elif cleaned.startswith("!blackbots") and is_mod:
            bots = self.translator.get_blacklisted_bots()
            if bots:
                bots_str = ", ".join(f"@{b}" for b in bots)
                await self.safe_send(
                    message.channel, f"üö´ Bots blacklist√©s ({len(bots)}): {bots_str}"
                )
            else:
                await self.safe_send(message.channel,  "‚ÑπÔ∏è Aucun bot dans la blacklist.")
            return

        # === TRADUCTION MANUELLE ===
        elif (cleaned.startswith("!translate ") or cleaned.startswith("!trad ")) and is_mod:
            # Extract text
            # Extract text
            text = (
                content_without_mention[11:].strip() if cleaned.startswith("!translate ") else content_without_mention[6:].strip()
            )
            if text:
                # Limite Twitch: ~500 chars max, on garde une marge
                MAX_INPUT_LENGTH = 200  # Limite input pour √©viter d√©bordement output
                if len(text) > MAX_INPUT_LENGTH:
                    await self.safe_send(
                        message.channel,
                        f"@{user} ‚ö†Ô∏è Texte trop long ({len(text)} chars). "
                        f"Limite: {MAX_INPUT_LENGTH} caract√®res pour la traduction."
                    )
                    return
                
                try:
                    # Detect language (simple heuristic)
                    has_french = any(
                        word in text.lower()
                        for word in ["le", "la", "les", "de", "du", "un", "une"]
                    )
                    source = "fr" if has_french else "en"
                    target = "en" if source == "fr" else "fr"

                    translated = self.translator.translate(text, source, target)
                    if translated and not translated.startswith("‚ö†Ô∏è"):
                        # flag_source = "üá´üá∑" if source == "fr" else "üá¨üáß"  # Unused for now
                        flag_target = "üá¨üáß" if source == "fr" else "üá´üá∑"
                        
                        # Format compact pour √©viter overflow
                        response = f"{flag_target} {translated}"
                        
                        # S√©curit√© finale: tronquer si trop long
                        if len(response) > 480:
                            response = response[:477] + "‚Ä¶"
                        
                        await self.safe_send(message.channel, response)
                    elif translated and translated.startswith("‚ö†Ô∏è"):
                        # Erreur de traduction avec message informatif
                        await self.safe_send(message.channel,  f"@{user} {translated}")
                    else:
                        await self.safe_send(
                            message.channel, f"@{user} ‚ùå Service de traduction indisponible."
                        )
                except (RuntimeError, ValueError, KeyError) as e:
                    print(f"‚ùå Erreur traduction manuelle: {e}")
                    await self.safe_send(
                        message.channel, f"@{user} ‚ùå Erreur critique de traduction."
                    )
            else:
                await self.safe_send(message.channel,  f"@{user} Usage: !translate <texte>")
            return

        if cleaned.startswith("!gameinfo ") and "game" in self.enabled:
            game_name = content_without_mention[10:].strip()
            await self.run_with_cooldown(
                user, lambda: handle_game_command(message, self.config, game_name, now, bot=self)
            )

        elif cleaned.startswith("!ask") and "ask" in self.enabled:
            query = content_without_mention[4:].strip()
            if query == "":
                await self.safe_send(
                    message.channel,
                    f"@{user} Tu as oubli√© de poser ta question. "
                    f"Utilise la commande `!ask ta_question`.",
                )
                return
            await self.run_with_cooldown(
                user, lambda: handle_ask_command(message, self.config, query, now, llm_available=self.llm_available, bot=self)
            )

        elif cleaned.startswith("!cacheadd "):
            # Commande admin: ajouter un fait au cache
            args = content_without_mention[10:].strip()
            await handle_cacheadd_command(message, self.config, args)

        elif cleaned == "!cachestats":
            # Commande admin: statistiques du cache
            await handle_cachestats_command(message, self.config)

        elif cleaned == "!cacheclear":
            # Commande admin: vider le cache (DANGER)
            await handle_cacheclear_command(message, self.config)

        elif cleaned.startswith("!donationserda") or cleaned.startswith("!serdakofi"):
            await self.run_with_cooldown(
                user, lambda: handle_donation_command(message, self.config, now)
            )

        elif is_mentioned and "chill" in self.enabled:
            await self.run_with_cooldown(
                user, lambda: handle_chill_command(message, self.config, now, conversation_manager=self.conversation_manager, llm_available=self.llm_available, bot=self, translator=self.translator)
            )

    async def safe_send(self, channel, content):
        """Envoie un message de mani√®re s√©curis√©e avec gestion des erreurs.

        Utilise l'API Send Chat Message (badge bot ü§ñ) avec fallback IRC.

        Args:
            channel: Le canal o√π envoyer le message
            content: Le contenu du message √† envoyer
        """
        if len(content) > 500:
            content = content[:497] + "..."
        
        # Essayer l'API d'abord (badge bot ü§ñ)
        if self.api_enabled:
            try:
                print(f"[API] üì§ Tentative d'envoi via API: {content[:100]}...")
                success = await self.api_sender.send_message(content, use_badge=True)
                if success:
                    print("[API] ‚úÖ Message envoy√© avec badge bot!")
                    return
                else:
                    print("[API] ‚ö†Ô∏è √âchec API, fallback vers IRC...")
            except Exception as e:
                print(f"[API] ‚ùå Exception API: {e}, fallback vers IRC...")
        
        # Fallback IRC si API d√©sactiv√©e ou √©chou√©e
        try:
            print(f"[IRC] üì§ Envoi via IRC: {content[:100]}...")
            await channel.send(content)
            print("[IRC] ‚úÖ Message envoy√©!")
        except ConnectionError as e:
            print(f"‚ùå Erreur de connexion lors de l'envoi: {e}")
        except TimeoutError as e:
            print(f"‚ùå D√©lai d√©pass√© lors de l'envoi: {e}")
        except (ValueError, RuntimeError) as e:
            print(f"‚ùå Erreur d'envoi du message: {e}")

    async def event_reconnect(self):
        """√âv√©nement appel√© par TwitchIO quand le serveur IRC envoie RECONNECT.
        
        TwitchIO 2.x reconnecte automatiquement apr√®s cet √©v√©nement.
        L'annonce sera faite dans event_channel_joined() au retour.
        """
        print("\n" + "="*60)
        print("[RECONNECT] üì® Message RECONNECT re√ßu de Twitch")
        print("[RECONNECT] ‚è≥ TwitchIO va reconnecter automatiquement...")
        print("="*60 + "\n")
    
    async def event_error(self, error, data=None):
        """Filet de s√©curit√©: d√©tecte et log les erreurs.
        
        Les erreurs r√©seau d√©clenchent une reconnexion auto de TwitchIO.
        L'annonce sera faite dans event_channel_joined() au retour.
        """
        exc_name = type(error).__name__ if error else "Unknown"
        print(f"[ERROR] ‚ö†Ô∏è Erreur d√©tect√©e: {exc_name}")
        
        # Log sp√©cifique pour les erreurs r√©seau
        if any(k in exc_name for k in ("ConnectionClosed", "WebSocket", "Timeout", "ConnectionError")):
            print(f"[ERROR] üîå Erreur de connexion ‚Üí TwitchIO va reconnecter automatiquement")
        
        # Affiche l'erreur pour debug
        if error:
            import traceback
            traceback.print_exception(type(error), error, error.__traceback__)
    
    async def event_channel_joined(self, channel):
        """√âv√©nement appel√© quand le bot (re)joint un salon (TwitchIO 2.10+).
        
        C'est ici qu'on annonce le retour apr√®s une reconnexion.
        """
        print(f"[JOIN] ‚úÖ Bot rejoint le salon: {channel.name}")
        
        # Si c'est la premi√®re fois qu'on joint, on marque juste
        if not self._channel_joined_once:
            self._channel_joined_once = True
            print("[JOIN] üìç Premi√®re connexion au salon")
            return
        
        # Si on avait d√©j√† joint avant, c'est une RECONNEXION
        if self._booted:
            print("[RECONNECT] üéâ Reconnexion d√©tect√©e! Annonce dans le chat...")
            
            # Cooldown anti-spam
            now = datetime.now().timestamp()
            cooldown = self.config.get("reconnect_announce_cooldown", 10)
            if now - self._last_reconnect_announce < cooldown:
                print(f"[RECONNECT] ‚è≥ Cooldown actif ({cooldown}s), message ignor√©")
                return
            
            self._last_reconnect_announce = now
            try:
                await channel.send("Me revoil√†, petite coupure de connexion ! üîå")
                print("[RECONNECT] ‚úÖ Message envoy√© avec succ√®s")
            except Exception as e:
                print(f"[RECONNECT] ‚ùå Impossible d'envoyer le message: {e}")
    


def run_bot(config):
    """Lance le bot Twitch avec la configuration donn√©e."""
    async def main():
        bot = TwitchBot(config)
        await bot.start()

    asyncio.run(main())

if __name__ == "__main__":
    try:
        run_bot(CONFIG)
    except Exception as e:
        print(f"[CRITICAL] Une erreur critique s'est produite : {e}")
        traceback.print_exc()
