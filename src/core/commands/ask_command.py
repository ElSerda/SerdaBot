"""Command handler for !ask - AI-powered question answering."""

import re
from twitchio import Message  # pyright: ignore[reportPrivateImportUsage]

from prompts.prompt_loader import make_prompt
from utils.model_utils import call_model
from src.utils.cache_manager import get_cached_or_fetch
from src.core.fallbacks import get_fallback_response


async def extract_game_entity(question: str) -> str | None:
    """Extrait le nom d'un jeu potentiel d'une question !ask.
    
    Exemples:
    - "Qui a d√©velopp√© Stardew Valley ?" ‚Üí "Stardew Valley"
    - "C'est quoi Celeste ?" ‚Üí "Celeste"
    - "Sur quelles plateformes est Hades ?" ‚Üí "Hades"
    - "Qui est le pr√©sident ?" ‚Üí None
    """
    # Pattern 1: Apr√®s "c'est quoi" ou "qu'est-ce que" (prioritaire)
    pattern_quoi = r"(?:c'est quoi|qu'est[- ]ce que)\s+(.+?)(?:\s*\?|$)"
    match = re.search(pattern_quoi, question, re.IGNORECASE)
    if match:
        entity = match.group(1).strip()
        # Nettoyer les articles
        entity = re.sub(r'^(le|la|les|un|une|des)\s+', '', entity, flags=re.IGNORECASE)
        if len(entity) > 2:
            return entity
    
    # Pattern 2: Noms propres cons√©cutifs avec majuscules (pour jeux multi-mots)
    # Ex: "Stardew Valley", "Baldur's Gate", "The Last of Us"
    # Chercher s√©quence de mots commen√ßant par majuscule + mots minuscules interm√©diaires (of, the, etc)
    pattern_multi = r'\b([A-Z][a-z]+(?:[\s\'][A-Z][a-z]+|[\s]+(?:of|the|and|de|du|des)[\s]+[A-Z][a-z]+)+)\b'
    matches = re.findall(pattern_multi, question)
    
    # Filtrer les mots communs (pas des noms de jeux)
    exclude_starts = {'Qui', 'Quoi', 'Comment', 'Quand', 'Quelle', 'Quel'}
    for match in matches:
        first_word = match.split()[0]
        if first_word not in exclude_starts and len(match) > 4:
            return match
    
    # Pattern 3: Nom propre simple (un seul mot avec majuscule)
    # Ex: "Hades", "Celeste", "Minecraft"
    pattern_single = r'\b([A-Z][a-z]{2,})\b'
    matches = re.findall(pattern_single, question)
    
    # Filtrer les mots communs
    exclude_single = {'Qui', 'Quoi', 'Comment', 'Quand', 'Quelle', 'Quel', 'Sur', 'Dans', 'France', 'Paris', 'Est'}
    candidates = [m for m in matches if m not in exclude_single and len(m) > 2]
    
    if candidates:
        # Retourner le premier candidat valide
        return candidates[0]
    
    return None


def format_game_answer(game_data: dict, question: str) -> str:
    """Formate une r√©ponse bas√©e sur les donn√©es RAWG et le type de question.
    
    Args:
        game_data: Dict retourn√© par fetch_game_data()
        question: Question originale de l'utilisateur
    
    Returns:
        R√©ponse format√©e et factuelle
    """
    name = game_data.get("name", "Ce jeu")
    question_lower = question.lower()
    
    # Type 1: Qui a d√©velopp√©/cr√©√© ?
    if any(word in question_lower for word in ["d√©velopp", "cr√©√©", "cr√©a", "fait", "dev", "studio"]):
        devs = game_data.get("developers", [])
        if devs:
            dev_str = " et ".join(devs[:3])  # Max 3 devs pour √©viter liste trop longue
            return f"{name} a √©t√© d√©velopp√© par {dev_str}."
        else:
            return f"Les d√©veloppeurs de {name} ne sont pas r√©pertori√©s."
    
    # Type 2: Qui a publi√©/√©dit√© ?
    if any(word in question_lower for word in ["publi", "√©dit", "publisher"]):
        pubs = game_data.get("publishers", [])
        if pubs:
            pub_str = " et ".join(pubs[:3])
            return f"{name} a √©t√© publi√© par {pub_str}."
        else:
            return f"Les √©diteurs de {name} ne sont pas r√©pertori√©s."
    
    # Type 3: Plateformes ?
    if any(word in question_lower for word in ["plateforme", "console", "pc", "o√π jouer", "dispo"]):
        platforms = game_data.get("platforms", [])
        if platforms:
            plat_str = ", ".join(platforms[:8])  # Max 8 plateformes
            return f"{name} est disponible sur : {plat_str}."
        else:
            return f"Les plateformes de {name} ne sont pas r√©pertori√©es."
    
    # Type 4: Date de sortie ?
    if any(word in question_lower for word in ["sortie", "sorti", "quand", "date", "ann√©e"]):
        year = game_data.get("release_year")
        date = game_data.get("release_date")
        if date:
            return f"{name} est sorti le {date}."
        elif year:
            return f"{name} est sorti en {year}."
        else:
            return f"La date de sortie de {name} n'est pas r√©pertori√©e."
    
    # Type 5: Genre ?
    if any(word in question_lower for word in ["genre", "type", "cat√©gorie"]):
        genres = game_data.get("genres", [])
        if genres:
            genre_str = ", ".join(genres[:3])
            return f"{name} est un jeu de type {genre_str}."
        else:
            return f"Le genre de {name} n'est pas r√©pertori√©."
    
    # Type 6: Note/Score ?
    if any(word in question_lower for word in ["note", "score", "avis", "rating", "metacritic"]):
        metacritic = game_data.get("metacritic")
        rating = game_data.get("rating")
        
        parts = []
        if metacritic:
            parts.append(f"Metacritic: {metacritic}/100")
        if rating:
            parts.append(f"Note RAWG: {rating}/5")
        
        if parts:
            return f"{name} - {', '.join(parts)}."
        else:
            return f"Les notes de {name} ne sont pas disponibles."
    
    # D√©faut: R√©sum√© complet (comme !gameinfo mais plus court)
    summary = game_data.get("summary", "")
    devs = game_data.get("developers", [])
    year = game_data.get("release_year")
    
    response = f"{name}"
    if year:
        response += f" ({year})"
    if devs:
        response += f" - d√©velopp√© par {', '.join(devs[:2])}"
    if summary:
        # Prendre premi√®re phrase du summary (max 200 chars)
        first_sentence = summary.split('.')[0][:200]
        response += f". {first_sentence}."
    
    return response


async def handle_ask_command(message: Message, config: dict, question: str, now, llm_available: bool = True):  # pylint: disable=unused-argument
    """Handle the !ask command to answer user questions using AI.
    
    Args:
        message: Message Twitch re√ßu
        config: Configuration du bot
        question: Question de l'utilisateur
        now: Timestamp actuel
        llm_available: Si le LLM est disponible (d√©faut: True pour r√©trocompatibilit√©)
    """
    user = (message.author.name or "user").lower()
    debug = config["bot"].get("debug", False)

    if not question.strip():
        await message.channel.send(
            f"@{user} Tu as oubli√© de poser ta question apr√®s `!ask`."
        )
        if debug:
            print(f"[ASK] ‚ö†Ô∏è Question vide re√ßue de @{user}")
        return

    if debug:
        print(f"[ASK] üîé Traitement de la question de @{user}...")

    # === NOUVELLE STRAT√âGIE: Essayer d'abord de d√©tecter un jeu vid√©o ===
    game_entity = await extract_game_entity(question)
    
    if game_entity:
        if debug:
            print(f"[ASK] üéÆ Entit√© jeu d√©tect√©e: '{game_entity}'")
            print(f"[ASK] üß† D√©cision: RAWG (jeu d√©tect√©)")
        
        # Tenter de r√©cup√©rer les donn√©es du jeu via RAWG (avec cache)
        try:
            from src.core.commands.api.game_data_fetcher import fetch_game_data
            
            game_data = await fetch_game_data(game_entity, config, cache_only=False)
            
            if game_data:
                if debug:
                    print(f"[ASK] ‚úÖ Donn√©es jeu trouv√©es via RAWG: {game_data.get('name')}")
                
                # Formater la r√©ponse bas√©e sur les donn√©es RAWG
                factual_response = format_game_answer(game_data, question)
                
                # S√©curit√© Twitch
                if len(factual_response) > 480:
                    factual_response = factual_response[:477] + "‚Ä¶"
                
                try:
                    if debug:
                        print(f"[ASK] üì§ R√©ponse factuelle RAWG: {factual_response[:100]}...")
                    await message.channel.send(f"@{user} {factual_response}")
                    if debug:
                        print(f"[ASK] ‚úÖ R√©ponse RAWG envoy√©e (0% LLM, 100% factuel)")
                    return
                except Exception as e:
                    print(f"[ASK] ‚ùå Erreur envoi: {e}")
                    return
            else:
                if debug:
                    print(f"[ASK] ‚ö†Ô∏è Jeu '{game_entity}' non trouv√© dans RAWG")
                    print(f"[ASK] üß† D√©cision: Fallback Wikipedia/LLM")
        except Exception as e:
            if debug:
                print(f"[ASK] ‚ö†Ô∏è Erreur fetch_game_data: {e}")
                print(f"[ASK] üß† D√©cision: Fallback Wikipedia/LLM")
    else:
        if debug:
            print(f"[ASK] üß† D√©cision: LLM (hors-jeu)")
    
    # === FALLBACK 1: Cache Wikipedia ===
    cached_answer = await get_cached_or_fetch(question)
    if cached_answer:
        if debug:
            print(f"[ASK] üí° R√©ponse depuis cache/Wikipedia")
        
        # S√©curit√© Twitch (500 chars max absolu avec @mention)
        final_response = cached_answer.strip()
        if len(final_response) > 480:
            final_response = final_response[:477] + "‚Ä¶"
        
        try:
            if debug:
                print(f"[SEND] üì§ Envoi CACHE: {final_response[:100]}...")
            await message.channel.send(f"@{user} {final_response}")
            if debug:
                print(f"[SEND] ‚úÖ Envoy√© avec succ√®s (cache)")
        except Exception as e:
            print(f"[SEND] ‚ùå Erreur envoi: {e}")
        return

    # === FALLBACK 2: Appel au mod√®le LLM (dernier recours) ===
    # V√©rifier si le LLM est disponible
    if not llm_available:
        if debug:
            print(f"[ASK] ü§ñ LLM non disponible ‚Üí mode fallback")
        
        fallback_msg = get_fallback_response("ask")
        
        try:
            await message.channel.send(f"@{user} {fallback_msg}")
            if debug:
                print(f"[ASK] ‚úÖ Fallback envoy√©: {fallback_msg}")
        except Exception as e:
            print(f"[SEND] ‚ùå Erreur envoi fallback: {e}")
        return
    
    if debug:
        print(f"[ASK] ü§ñ Appel mod√®le LLM (dernier recours)...")
    
    # R√©cup√©rer game/title depuis config (si disponible)
    game = config.get("stream", {}).get("game")
    title = config.get("stream", {}).get("title")

    # Construire le prompt avec make_prompt
    prompt = make_prompt(mode="ask", content=question, user=user, game=game, title=title)
    
    if debug:
        print(f"[ASK] üìù USER Prompt ({len(prompt)} chars): {prompt[:150]}{'...' if len(prompt) > 150 else ''}")
    
    response = await call_model(prompt, config, user=user, mode="ask")

    if not response:
        await message.channel.send(f"@{user} ‚ö†Ô∏è Erreur ou pas de r√©ponse.")
        return

    # S√©curit√© Twitch (500 chars max absolu avec @mention)
    final_response = response.strip()
    if len(final_response) > 480:
        final_response = final_response[:477] + "‚Ä¶"

    try:
        if debug:
            print(f"[SEND] üì§ Envoi ASK LLM: {final_response[:100]}...")
        await message.channel.send(f"@{user} {final_response}")
        if debug:
            print(f"[ASK] ‚úÖ R√©ponse LLM envoy√©e √† @{user}")
    except Exception as e:
        print(f"[ASK] ‚ùå Erreur d'envoi: {e}")
